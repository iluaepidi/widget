{
  "name": "gpii-test-browser",
  "version": "0.0.1",
  "description": "Fluid component to allow browser testing using Nightmare...",
  "main": "index.js",
  "scripts": {
    "test": "node tests/all-tests.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/GPII/gpii-test-browser.git"
  },
  "author": {
    "name": "Tony Atkins",
    "email": "tony@raisingthefloor.org"
  },
  "license": "BSD-3-Clause",
  "dependencies": {
    "infusion": "2.0.0-dev.20151211T025229Z.eabb4fc",
    "nightmare": "2.1.6"
  },
  "devDependencies": {
    "cookie": "^0.2.0",
    "gpii-express": "git://github.com/the-t-in-rtf/gpii-express.git#59e852d74d5a198bb96190d47073b97fff224fd9",
    "grunt": "0.4.4",
    "grunt-contrib-jshint": "0.9.0",
    "grunt-jsonlint": "1.0.4",
    "grunt-shell": "0.6.4",
    "kettle": "git://github.com/amb26/kettle.git#2517cc1d9d047d58aef70db48d1580da718ffc16",
    "node-jqunit": "~1.1.3"
  },
  "gitHead": "dc66ced403922dd1e29d7359cd051a780ea22749",
  "readme": "# Introduction\n\nThis package provides a set of Fluid components designed to assist in testing complex suites of components, such as\nthose which have both a server and client side.  It is based on [Nightmare.js](https://github.com/segmentio/nightmare),\nwhich itself uses [Atom Electron](https://github.com/atom/electron).  The ultimate goal of this package is to allow\nyou to test your components using only Fluid IoC test fixtures, and in many cases, only test sequence definitions.\n\n# How does `Nightmare` work?\n\nNightmare allows you to send commands to and inspect the state of an Atom Electron browser.  The browser can run with a\nvisible output window, or in \"headless\" mode.  Typically, you will:\n\n 1. `goto` a starting page.\n 2. Optionally `inject` javascript used by your tests.\n 2. Execute one or more actions (such as `click`, `type`, or `submit`).\n 3. Evaluate the state of the browser.\n\n# Adding this package to your tests\n\nYou will typically use this package by wiring an instance of `gpii.tests.browser` into your `testEnvironment`.\nThere is a reusable set of test components provided with this package, which can be used from your tests by adding\nboilerplate like:\n\n```\nrequire(\"gpii-test-browser\");\ngpii.tests.browser.loadTestingSupport();\n```\n\nOnce you have done this, you can use the provided caseHolder (`gpii.tests.browser.caseHolder.static`) and test\nenvironment (`gpii.tests.browser.environment`) in your tests.  These include wiring to ensure that the tests are fired\nonce QUnit is ready, and to ensure that the browser is shut down completely at the end of each test.\n\n# How does this package work?\n\nEach of the underlying [Nightmare.js](https://github.com/segmentio/nightmare) functions is available via a\ncorresponding invoker.  Each function's use has been simplified and standardized for use in test cases.\n\nThere is no option to supply a callback to any Nightmare function.  Instead, a call to a Nightmare functions ultimately\nfires a corresponding component event with the result.  For example, `goto` fires `onGotoComplete` when it completes.\nThis allows you to chain complex operations and inspections together in a standard Fluid IoC test sequence, as in this\nexample:\n\n```\n{\n    name: \"Test clicking a link...\",\n    sequence: [\n        {\n            func: \"{gpii.tests.browser.environment}.browser.goto\",\n            args: [startUrl]\n        },\n        {\n            listener: \"{gpii.tests.browser.environment}.browser.click\",\n            event:    \"{gpii.tests.browser.environment}.browser.events.onGotoComplete\",\n            args:     [\"a\"]\n        },\n        {\n            event:    \"{gpii.tests.browser.environment}.browser.events.onClickComplete\",\n            listener: \"{gpii.tests.browser.environment}.browser.evaluate\",\n            args:     [gpii.tests.browser.tests.textLookupFunction, \"body\"]\n        },\n        {\n            listener: \"jqUnit.assertEquals\",\n            event:    \"{gpii.tests.browser.environment}.browser.events.onEvaluateComplete\",\n            args:     [\"The body should be as expected...\", \"This is the second page.\", \"{arguments}.0\"]\n        }\n    ]\n}\n```\n\n# Evaluating the State of the Browser\n\nCommonly, you will want to test the state of the browser to confirm whether one or more conditions is true. Nightmare\nprovides a few functions to confirm the existance or visibility of an element based on a selector.  It also provides\nfunctions to examine the title and URL of the browser window.  You can listen for the result of these\nactions with a `jqUnit` method, as in the following example:\n\n```\nname: \"Test querying the title of a sample page...\",\nsequence: [\n    {\n        func: \"{gpii.tests.browser.environment}.browser.goto\",\n        args: [goodUrl]\n    },\n    {\n        event:    \"{gpii.tests.browser.environment}.browser.events.onGotoComplete\",\n        listener: \"{gpii.tests.browser.environment}.browser.title\"\n    },\n    {\n        listener: \"jqUnit.assertEquals\",\n        event:    \"{gpii.tests.browser.environment}.browser.events.onTitleComplete\",\n        args:     [\"The title should be as expected...\", \"Test environment for exercising Nightmare\", \"{arguments}.0\"]\n    }\n]\n```\nFor more complex inspections, you'll want to use the `evaluate` method.  This allows you to pass in either one of\nthe functions provided by this package (see \"advanced topics\" below)or one or your own choosing.  A few things to note:\n\n1. The function will be evaluated within the browser, and needs to be self-contained.\n2. If an error occurs in executing the function, it will be passed along to the `onError` event.\n3. You will generally want to return a value from the function, which will be passed along when the `onEvaluateComplete` event is fired.\n4. You will typically want to return simple values.  Complex objects such as the `document` and `window` are stripped of their functions (see \"advanced topics\" below).\n\n# Further Reading\n\nCheck out the Nightmare documentation for details on what a function is meant to do.  Review the tests in\nthis package for examples of how each can be used from within a test sequence.\n\n# Advanced topics\n\n## What predefined functions are available?\n\nThis package provides simple, dependency-free functions that can be passed to `evaluate`, which are as follows:\n\n| Component | Arguments | Returns |\n| --------- | --------- | ------- |\n|`gpii.tests.browser.tests.textLookupFunction`| `selector`: A CSS-style selector that can be used with `document.querySelector`. | The `innerText` of the selected element. |\n|`gpii.tests.browser.tests.LookupFunction`| `selector`: A CSS-style selector that can be used with `document.querySelector`. | The `innerHTML` of the selected element. |\n|`gpii.tests.browser.tests.valueLookupFunction`| `selector`: A CSS-style selector that can be used with `document.querySelector`. | The `value` of the selected element. |\n\n## What can be returned from `evaluate`?\n\nIf none of the above functions meet your needs, you may want to create your own function.  In that case, you need to\nknow what can be returned. Let's say that you have the following client-side component on your page:\n\n```\n<script type=\"text/javascript\">\n    var component = fluid.modelComponent({\n        data: {\n            isAwesome: true\n        },\n        members: {\n            myId: \"12345\"\n        },\n        model: {\n            count: 0\n        }\n    });\n    component.applier.change(\"count\", 1);\n</script>\n```\n\nLet's say also that you passed the following function to `evaluate`:\n\n```\nfunction () {\n    return component;\n}\n```\n\nThe result would look like:\n\n```\n{\n  \"applier\": {\n    \"applierId\": \"aa64te49-14\",\n    \"changeListeners\": {\n      \"listeners\": [],\n      \"transListeners\": []\n    },\n    \"holder\": null,\n    \"modelChanged\": {},\n    \"options\": null,\n    \"postCommit\": {\n      \"byId\": {\n        \"aa64te49-19\": null\n      },\n      \"eventId\": \"aa64te49-16\",\n      \"listeners\": {\n        \"aa64te49-19\": [\n          {\n            \"namespace\": \"aa64te49-19\",\n            \"priority\": {\n              \"constraint\": null,\n              \"count\": 0,\n              \"fixed\": 0,\n              \"site\": \"listeners\"\n            }\n          }\n        ]\n      },\n      \"name\": \"postCommit event for ChangeApplier \",\n      \"sortedListeners\": [\n        null\n      ],\n      \"typeName\": \"fluid.event.firer\"\n    },\n    \"preCommit\": {\n      \"byId\": {\n        \"aa64te49-17\": null,\n        \"aa64te49-18\": null\n      },\n      \"eventId\": \"aa64te49-15\",\n      \"listeners\": {\n        \"aa64te49-17\": [\n          {\n            \"namespace\": \"aa64te49-17\",\n            \"priority\": {\n              \"constraint\": null,\n              \"count\": 0,\n              \"fixed\": 0,\n              \"site\": \"listeners\"\n            }\n          }\n        ],\n        \"aa64te49-18\": [\n          {\n            \"namespace\": \"aa64te49-18\",\n            \"priority\": {\n              \"constraint\": null,\n              \"count\": 1,\n              \"fixed\": 0.0009765625,\n              \"site\": \"listeners\"\n            }\n          }\n        ]\n      },\n      \"name\": \"preCommit event for ChangeApplier \",\n      \"sortedListeners\": [\n        null,\n        null\n      ],\n      \"typeName\": \"fluid.event.firer\"\n    }\n  },\n  \"events\": {\n    \"afterDestroy\": {\n      \"eventId\": \"aa64te49-13\",\n      \"name\": \"afterDestroy of component with typename fluid.modelComponent and id aa64te49-10\",\n      \"ownerId\": \"aa64te49-10\",\n      \"typeName\": \"fluid.event.firer\"\n    },\n    \"onCreate\": {\n      \"eventId\": \"aa64te49-11\",\n      \"name\": \"onCreate of component with typename fluid.modelComponent and id aa64te49-10\",\n      \"ownerId\": \"aa64te49-10\",\n      \"typeName\": \"fluid.event.firer\"\n    },\n    \"onDestroy\": {\n      \"eventId\": \"aa64te49-12\",\n      \"name\": \"onDestroy of component with typename fluid.modelComponent and id aa64te49-10\",\n      \"ownerId\": \"aa64te49-10\",\n      \"typeName\": \"fluid.event.firer\"\n    }\n  },\n  \"id\": \"aa64te49-10\",\n  \"lifecycleStatus\": \"treeConstructed\",\n  \"model\": {\n    \"count\": 1\n  },\n  \"modelRelay\": null,\n  \"myId\": \"12345\",\n  \"options\": {\n    \"argumentMap\": {\n      \"options\": 0\n    },\n    \"changeApplierOptions\": {\n      \"cullUnchanged\": true,\n      \"relayStyle\": true,\n      \"resolverGetConfig\": {\n        \"parser\": null,\n        \"strategies\": [\n          null\n        ]\n      },\n      \"resolverSetConfig\": {\n        \"parser\": {},\n        \"strategies\": [\n          null,\n          null\n        ]\n      }\n    },\n    \"data\": {\n      \"isAwesome\": true\n    },\n    \"events\": {\n      \"afterDestroy\": null,\n      \"onCreate\": null,\n      \"onDestroy\": null\n    },\n    \"gradeNames\": [\n      \"fluid.component\",\n      \"fluid.modelComponent\"\n    ],\n    \"initFunction\": \"fluid.initLittleComponent\",\n    \"members\": {\n      \"applier\": {\n        \"0\": {\n          \"expander\": {\n            \"args\": [\n              \"{that}\",\n              \"{that}.options.changeApplierOptions\"\n            ],\n            \"funcName\": \"fluid.makeHolderChangeApplier\"\n          }\n        },\n        \"length\": 1\n      },\n      \"model\": {\n        \"0\": {\n          \"expander\": {\n            \"args\": [\n              \"{that}\",\n              \"{that}.modelRelay\"\n            ],\n            \"funcName\": \"fluid.initRelayModel\"\n          }\n        },\n        \"length\": 1\n      },\n      \"modelRelay\": {\n        \"0\": {\n          \"expander\": {\n            \"args\": [\n              \"{that}\",\n              \"{that}.options.model\",\n              \"{that}.options.modelListeners\",\n              \"{that}.options.modelRelay\",\n              \"{that}.applier\"\n            ],\n            \"funcName\": \"fluid.establishModelRelay\"\n          }\n        },\n        \"length\": 1\n      },\n      \"myId\": {\n        \"0\": \"12345\",\n        \"length\": 1\n      }\n    },\n    \"model\": [\n      {\n        \"count\": 0\n      }\n    ]\n  },\n  \"typeName\": \"fluid.modelComponent\"\n}\n```\n\nSo, you can see the model data, you can see the options, you can see member data, but you can't use\nany invokers or other functions that were originally part of your component.  If you need to arbitrarily modify a\nclient-side component, you can:\n\n1. Inject client-side scripts that perform the work.\n2. Evalute the results once the `onInjectComplete` event is fired.",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/GPII/gpii-test-browser/issues"
  },
  "homepage": "https://github.com/GPII/gpii-test-browser#readme",
  "_id": "gpii-test-browser@0.0.1",
  "_shasum": "85ad8333d707b1faae16908fa986ea7b9137aacb",
  "_from": "git://github.com/the-t-in-rtf/gpii-test-browser.git#dc66ced403922dd1e29d7359cd051a780ea22749",
  "_resolved": "git://github.com/the-t-in-rtf/gpii-test-browser.git#dc66ced403922dd1e29d7359cd051a780ea22749"
}
